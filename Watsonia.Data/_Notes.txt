THINGS TO WORK ON:

Allow properties to be abstract as well as virtual (specifically for IsValid and ValidationErrors)?
	And change ValidationErrors to an IList
Implement INotifyingDataError
Have better error messages
	When a standard overridden property is of the wrong type e.g. if HasChanges is a string
	When a standard overridden property has the wrong access type e.g. if HasChanges only has a getter
	When an unusual collection is used (one that doesn't take an IList<T> in a constructor)
	When calling Select.And without Select.Where
Test using Guids for IDs
	And compound IDs
	And no IDs
Add async support - something like EntityFrameworkQueryableExtensions.cs?
Duplicate less code between SQLite and SQL Server
Fix up the documentation
	Make a list of conventions
Performance improvements!
	Should we use the type-specific methods (GetInt32 etc) in SetValuesFromReader?
	Should we have SetValue(propertyName) methods instead of using reflection?
	Should we store table name and related table names in the proxy? Or cache mappings in the database?  
	Basically, remove the using System.Reflection directive in Database and DynamicProxyStateTracker
	Also, use something better than Dictionary<string, object> (or anything that uses objects)
LoadedCollections and LoadedItems should probably be a collection of collections and items, rather than names?
Put it up on NuGet
Have a poke through the generated assembly to see where things can be improved
More XML commenting throughout

Should primary key columns be nullable?  New items could have their ID set to null and we could get
rid of GetPrimaryKeyNewItemValue
Add attributes for basically everything that can be set in the configuration

Having methods defined on IDynamicProxy introduces the risk of clashes with base class names.  We should
probably allow the user to set method names in DatabaseConfiguration that override base class methods
and then we just create calls to the appropriate methods in DynamicProxyStateTracker

Use Merge to insert/update large amounts of data?  It's what EF Core seems to do...

Get the query building functionality from Watsonia.QueryBuilder
Check that the types match in DataEntity.Equals

Can we do e.g. (from a in db.Query<Thing>() where !a.IsActive).Delete() ?!
Can we do e.g. (from a in db.Query<Thing>() where !a.IsActive).Update(a => a.IsActive, true) ?!
	(see the OpenIddict stores...)

SqlBulkInsert?!

extend the benchmark to inserting/updating/deleting
and print it out nicer


THINGS THAT WOULD BE AWESOME BUT TIME CONSUMING:

Add a query result cache a la EntityFramework.Extended
Add a second level cache
Add a PostgreSQL implementation
Add a MongoDB implementation
Add syncing functionality for multiple databases
A Glimpse plugin
